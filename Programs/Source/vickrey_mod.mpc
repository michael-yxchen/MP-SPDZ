from Compiler.library import print_ln
import util
from Compiler import types

import math
import re
import random
r = re.search('(\D*)(\d*)', program.name)

if r.group(2):
    n_inputs = int(r.group(2))
else:
    n_inputs = 11

n_parties = n_inputs
n_threads = n_parties
n_loops = 1
n_bits = 32
value_type = sint
sint_max = 10000000

program.set_bit_length(n_bits)
program.set_security(40)

# print_ln('n_inputs = %s, n_parties = %s, n_threads = %s, n_loops = %s, '
#          'value_type = %s',
#          n_inputs, n_parties, n_threads, n_loops, value_type.__name__)

@for_range(n_loops)
def f(_):
    Bid = types.getNamedTupleType('party', 'price', 'target')
    bids = Bid.get_array(n_inputs, value_type)
    bids_adj = Bid.get_array(n_inputs, value_type)
    bids_cp = Bid.get_array(n_inputs, value_type)


    for i in range(n_inputs):
        bids[i] = Bid(i, value_type.get_input_from(i), value_type.get_input_from(i))
        bids_cp[i] = bids[i]
        # print_ln("bidder %s bid %s target %s", i, bids[i].price.reveal(), bids[i].target.reveal())
    
    # adjustment phase
    """
    # print_ln("after adjustment phase!")
    def thread():
        i = get_arg()
        # adjust the price for bidder i
        cur_tgt = bids[i].target
        beta_bar = sint.hard_conv(sint_max)
        for it in range(n_inputs):
            for j in range(n_inputs):
                is_tgt = (cur_tgt == j)
                smaller = beta_bar.min(bids[j].price)
                beta_bar = is_tgt.if_else(smaller, beta_bar)
                cur_tgt = is_tgt.if_else(bids[j].target, cur_tgt)
        
        adjusted_price = (beta_bar <= bids[i].price).if_else(beta_bar, (beta_bar + bids[i].price)>>1)
        bids_adj[i] = Bid(i, adjusted_price, bids[i].target)
        # print_ln("bidder %s bid %s target %s", i,adjusted_price.reveal(), bids[i].target.reveal())
        # print_ln("adjusted price %s beta_bar %s", adjusted_price.reveal(), beta_bar.reveal())
            
    tape = program.new_tape(thread)
    threads = [program.run_tape(tape, i) for i in range(n_threads)]
    for i in threads:
        program.join_tape(i)
    """
    
    
    for i in range(n_inputs):
        cur_tgt = bids[i].target
        beta_bar = sint.hard_conv(sint_max)
        for it in range(n_inputs):
            for j in range(n_inputs):
                is_tgt = (cur_tgt == j)
                smaller = beta_bar.min(bids[j].price)
                beta_bar = is_tgt.if_else(smaller, beta_bar)
                cur_tgt = is_tgt.if_else(bids[j].target, cur_tgt)
        
        adjusted_price = (beta_bar <= bids[i].price).if_else(beta_bar, (beta_bar + bids[i].price)>>1)
        bids_adj[i] = Bid(i, adjusted_price, bids[i].target)
        # print_ln("bidder %s bid %s target %s", i,adjusted_price.reveal(), bids[i].target.reveal())
    

    def bubble_sort(a):
        res = a
        for i in range(n_inputs - 1):
            for j in range(n_inputs-i-1):
                comp = res[j].price < res[j+1].price
                res[j], res[j+1] = util.cond_swap(comp, res[j], res[j+1])
        return res
    # very stupid library sort!
    bids_sorted = bubble_sort(bids)
    first = bids_sorted[0]
    second = bids_sorted[1]
    bids_adj_sorted = bubble_sort(bids_adj)
    first_adj = bids_adj_sorted[0]
    second_adj = bids_adj_sorted[1]
    third_adj = bids_adj_sorted[2]

    apply_vickrey = (first.party == first.target)
    apply_vickrey = apply_vickrey.if_else(second.party == second.target, apply_vickrey)
    firstgap_greater = ((first_adj.price-second_adj.price) >= (second_adj.price-third_adj.price))

    gap_winner = firstgap_greater.if_else(first_adj, second_adj)
    gap_price = firstgap_greater.if_else(second_adj.party, third_adj.party)

    winner = apply_vickrey.if_else(first, gap_winner)
    price_party = apply_vickrey.if_else(second.party, gap_price)

    print_ln("Winner: %s, price: %s", winner.party.reveal(), bids_cp[price_party.reveal()].price.reveal())
